import createMiddleware from 'next-intl/middleware';
import { NextResponse, type NextRequest } from 'next/server';
// Restore Supabase/Auth related imports
import { createMiddlewareClient } from '@/lib/supabase/middleware-client';
import { isPublicRoute } from '@/lib/utils/routes';
import { routing } from './i18n/routing';
// Import Database type if needed for RPC response typing
// import { Database } from '@/types/supabase';

// Create the next-intl middleware
const intlMiddleware = createMiddleware(routing);

export async function middleware(request: NextRequest) {
  console.log('üõ°Ô∏è Middleware running for:', request.nextUrl.pathname);

  // Run next-intl middleware first to handle locale redirects/detection
  const intlResponse = intlMiddleware(request);

  // --- Modified Check for Redirect/Rewrite ---
  // Check if the response status indicates a redirect (3xx) or if it's a rewrite
  const isRedirect = intlResponse.status >= 300 && intlResponse.status < 400;
  const isRewrite = intlResponse.headers.has('x-middleware-rewrite');

  if (isRedirect || isRewrite) {
    console.log(
      `üõ°Ô∏è next-intl middleware handled the request (Status: ${intlResponse.status}, Rewrite: ${isRewrite}).`,
    );
    return intlResponse;
  }

  // If next-intl didn't handle it, proceed with existing Supabase/Auth logic
  console.log('üõ°Ô∏è next-intl middleware passed through, running auth checks...');

  try {
    const { supabase, response: supabaseResponse } =
      createMiddlewareClient(request);

    const pathname = request.nextUrl.pathname;
    const urlLocale = routing.locales.find((loc) =>
      pathname.startsWith(`/${loc}/`),
    );
    const pathWithoutLocale = urlLocale
      ? pathname.substring(urlLocale.length + 1)
      : pathname;

    const isPublic = isPublicRoute(pathWithoutLocale);
    console.log(`üõ°Ô∏è Path (w/o locale): ${pathWithoutLocale}`);
    console.log(`üõ°Ô∏è Is path public? ${isPublic ? 'Yes' : 'No'}`);

    if (isPublic) {
      console.log('üõ°Ô∏è Path is public, allowing access');
      return supabaseResponse;
    }

    const {
      data: { session },
      error: sessionError,
    } = await supabase.auth.getSession();

    if (sessionError) {
      console.error('üõ°Ô∏è Error fetching session:', sessionError);
      return NextResponse.redirect(new URL('/', request.url));
    }

    console.log(
      'üõ°Ô∏è Auth check:',
      session ? 'User is authenticated' : 'No authenticated user',
    );

    if (!session) {
      console.log('üõ°Ô∏è No session found, redirecting to locale root');
      const url = new URL('/', request.url);
      return NextResponse.redirect(url);
    }

    if (pathWithoutLocale.startsWith('/dashboard/admin')) {
      // Restore admin check logic if it was removed
      console.log('üõ°Ô∏è Accessing admin route, checking role...');
      const { data: isAdmin, error: rpcError } = await supabase.rpc('is_admin');

      if (rpcError) {
        console.error('üõ°Ô∏è Error calling is_admin RPC:', rpcError);
        return NextResponse.redirect(
          new URL(`${urlLocale ? '/' + urlLocale : ''}/dashboard`, request.url),
        );
      }

      console.log(`üõ°Ô∏è User is admin? ${isAdmin ? 'Yes' : 'No'}`);
      if (!isAdmin) {
        console.log('üõ°Ô∏è User is not admin, redirecting to general dashboard');
        return NextResponse.redirect(
          new URL(`${urlLocale ? '/' + urlLocale : ''}/dashboard`, request.url),
        );
      }
      console.log('üõ°Ô∏è User is admin, allowing access to admin route');
    }

    console.log('üõ°Ô∏è Auth checks passed, allowing access.');
    return supabaseResponse;
  } catch (e) {
    console.error('üõ°Ô∏è Middleware error:', e);
    const urlLocale = routing.locales.find((loc) =>
      request.nextUrl.pathname.startsWith(`/${loc}/`),
    );
    const pathWithoutLocale = urlLocale
      ? request.nextUrl.pathname.substring(urlLocale.length + 1)
      : request.nextUrl.pathname;

    if (pathWithoutLocale.startsWith('/dashboard')) {
      return NextResponse.redirect(new URL('/', request.url));
    }

    console.log('üõ°Ô∏è Non-protected route error, passing through.');
    return NextResponse.next({
      request: {
        headers: request.headers,
      },
    });
  }
}

export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * - Any files extensions like .svg, .png, etc.
     * Include /api routes so next-intl can prefix them.
     */
    '/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)',
  ],
};
